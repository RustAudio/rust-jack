#![allow(non_camel_case_types, non_upper_case_globals)]

#[macro_use]
extern crate lazy_static;
extern crate libc;
extern crate libloading;

/// JACK port type for 8 bit raw midi
pub static RAW_MIDI_TYPE: &'static str = "8 bit raw midi";

/// JACK port type for 32 bit float mono audio
pub static FLOAT_MONO_AUDIO: &'static str = "32 bit float mono audio";

/* automatically generated by rust-bindgen */

pub type jack_native_thread_t = ::libc::pthread_t;
pub type jack_uuid_t = ::libc::uint64_t;
pub type jack_shmsize_t = ::libc::int32_t;
pub type jack_nframes_t = ::libc::uint32_t;
pub type jack_time_t = ::libc::uint64_t;
pub type jack_intclient_t = ::libc::uint64_t;
pub enum Struct__jack_port {
}
pub type jack_port_t = Struct__jack_port;
pub enum Struct__jack_client {
}
pub type jack_client_t = Struct__jack_client;
pub type jack_port_id_t = ::libc::uint32_t;
pub type jack_port_type_id_t = ::libc::uint32_t;
pub type Enum_JackOptions = ::libc::c_uint;
pub const JackNullOption: ::libc::c_uint = 0;
pub const JackNoStartServer: ::libc::c_uint = 1;
pub const JackUseExactName: ::libc::c_uint = 2;
pub const JackServerName: ::libc::c_uint = 4;
pub const JackLoadName: ::libc::c_uint = 8;
pub const JackLoadInit: ::libc::c_uint = 16;
pub const JackSessionID: ::libc::c_uint = 32;
pub type jack_options_t = Enum_JackOptions;
pub type Enum_JackStatus = ::libc::c_uint;
pub const JackFailure: ::libc::c_uint = 1;
pub const JackInvalidOption: ::libc::c_uint = 2;
pub const JackNameNotUnique: ::libc::c_uint = 4;
pub const JackServerStarted: ::libc::c_uint = 8;
pub const JackServerFailed: ::libc::c_uint = 16;
pub const JackServerError: ::libc::c_uint = 32;
pub const JackNoSuchClient: ::libc::c_uint = 64;
pub const JackLoadFailure: ::libc::c_uint = 128;
pub const JackInitFailure: ::libc::c_uint = 256;
pub const JackShmFailure: ::libc::c_uint = 512;
pub const JackVersionError: ::libc::c_uint = 1024;
pub const JackBackendError: ::libc::c_uint = 2048;
pub const JackClientZombie: ::libc::c_uint = 4096;
pub type jack_status_t = Enum_JackStatus;
pub type Enum_JackLatencyCallbackMode = ::libc::c_uint;
pub const JackCaptureLatency: ::libc::c_uint = 0;
pub const JackPlaybackLatency: ::libc::c_uint = 1;
pub type jack_latency_callback_mode_t = Enum_JackLatencyCallbackMode;
pub type JackLatencyCallback = ::std::option::Option<
    unsafe extern "C" fn(mode: jack_latency_callback_mode_t, arg: *mut ::libc::c_void) -> (),
>;
#[repr(C, packed)]
#[derive(Copy)]
pub struct Struct__jack_latency_range {
    pub min: jack_nframes_t,
    pub max: jack_nframes_t,
}
impl ::std::clone::Clone for Struct__jack_latency_range {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct__jack_latency_range {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_latency_range_t = Struct__jack_latency_range;
pub type JackProcessCallback = ::std::option::Option<
    unsafe extern "C" fn(nframes: jack_nframes_t, arg: *mut ::libc::c_void) -> ::libc::c_int,
>;
pub type JackThreadCallback =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void) -> *mut ::libc::c_void>;
pub type JackThreadInitCallback =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void) -> ()>;
pub type JackGraphOrderCallback =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void) -> ::libc::c_int>;
pub type JackXRunCallback =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void) -> ::libc::c_int>;
pub type JackBufferSizeCallback = ::std::option::Option<
    unsafe extern "C" fn(nframes: jack_nframes_t, arg: *mut ::libc::c_void) -> ::libc::c_int,
>;
pub type JackSampleRateCallback = ::std::option::Option<
    unsafe extern "C" fn(nframes: jack_nframes_t, arg: *mut ::libc::c_void) -> ::libc::c_int,
>;
pub type JackPortRegistrationCallback = ::std::option::Option<
    unsafe extern "C" fn(port: jack_port_id_t, arg1: ::libc::c_int, arg: *mut ::libc::c_void) -> (),
>;
pub type JackClientRegistrationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::libc::c_char,
        arg1: ::libc::c_int,
        arg: *mut ::libc::c_void,
    ) -> (),
>;
pub type JackPortConnectCallback = ::std::option::Option<
    unsafe extern "C" fn(
        a: jack_port_id_t,
        b: jack_port_id_t,
        connect: ::libc::c_int,
        arg: *mut ::libc::c_void,
    ) -> (),
>;
pub type JackPortRenameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        port: jack_port_id_t,
        old_name: *const ::libc::c_char,
        new_name: *const ::libc::c_char,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int,
>;
pub type JackFreewheelCallback = ::std::option::Option<
    unsafe extern "C" fn(starting: ::libc::c_int, arg: *mut ::libc::c_void) -> (),
>;
pub type JackShutdownCallback =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void) -> ()>;
pub type JackInfoShutdownCallback = ::std::option::Option<
    unsafe extern "C" fn(
        code: jack_status_t,
        reason: *const ::libc::c_char,
        arg: *mut ::libc::c_void,
    ) -> (),
>;
pub type jack_default_audio_sample_t = ::libc::c_float;
pub type Enum_JackPortFlags = ::libc::c_uint;
pub const JackPortIsInput: ::libc::c_uint = 1;
pub const JackPortIsOutput: ::libc::c_uint = 2;
pub const JackPortIsPhysical: ::libc::c_uint = 4;
pub const JackPortCanMonitor: ::libc::c_uint = 8;
pub const JackPortIsTerminal: ::libc::c_uint = 16;
pub type Enum_Unnamed1 = ::libc::c_uint;
pub const JackTransportStopped: ::libc::c_uint = 0;
pub const JackTransportRolling: ::libc::c_uint = 1;
pub const JackTransportLooping: ::libc::c_uint = 2;
pub const JackTransportStarting: ::libc::c_uint = 3;
pub const JackTransportNetStarting: ::libc::c_uint = 4;
pub type jack_transport_state_t = Enum_Unnamed1;
pub type jack_unique_t = ::libc::uint64_t;
pub type Enum_Unnamed2 = ::libc::c_uint;
pub const JackPositionBBT: ::libc::c_uint = 16;
pub const JackPositionTimecode: ::libc::c_uint = 32;
pub const JackBBTFrameOffset: ::libc::c_uint = 64;
pub const JackAudioVideoRatio: ::libc::c_uint = 128;
pub const JackVideoFrameOffset: ::libc::c_uint = 256;
pub type jack_position_bits_t = Enum_Unnamed2;
#[repr(C, packed)]
#[derive(Copy)]
pub struct Struct__jack_position {
    pub unique_1: jack_unique_t,
    pub usecs: jack_time_t,
    pub frame_rate: jack_nframes_t,
    pub frame: jack_nframes_t,
    pub valid: jack_position_bits_t,
    pub bar: ::libc::int32_t,
    pub beat: ::libc::int32_t,
    pub tick: ::libc::int32_t,
    pub bar_start_tick: ::libc::c_double,
    pub beats_per_bar: ::libc::c_float,
    pub beat_type: ::libc::c_float,
    pub ticks_per_beat: ::libc::c_double,
    pub beats_per_minute: ::libc::c_double,
    pub frame_time: ::libc::c_double,
    pub next_time: ::libc::c_double,
    pub bbt_offset: jack_nframes_t,
    pub audio_frames_per_video_frame: ::libc::c_float,
    pub video_offset: jack_nframes_t,
    pub padding: [::libc::int32_t; 7usize],
    pub unique_2: jack_unique_t,
}
impl ::std::clone::Clone for Struct__jack_position {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct__jack_position {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_position_t = Struct__jack_position;
pub type JackSyncCallback = ::std::option::Option<
    unsafe extern "C" fn(
        state: jack_transport_state_t,
        pos: *mut jack_position_t,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int,
>;
pub type TimebaseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        state: jack_transport_state_t,
        nframes: jack_nframes_t,
        pos: *mut jack_position_t,
        new_pos: ::libc::c_int,
        arg: *mut ::libc::c_void,
    ) -> (),
>;
pub type Enum_Unnamed3 = ::libc::c_uint;
pub const JackTransportState: ::libc::c_uint = 1;
pub const JackTransportPosition: ::libc::c_uint = 2;
pub const JackTransportLoop: ::libc::c_uint = 4;
pub const JackTransportSMPTE: ::libc::c_uint = 8;
pub const JackTransportBBT: ::libc::c_uint = 16;
pub type jack_transport_bits_t = Enum_Unnamed3;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub frame_rate: jack_nframes_t,
    pub usecs: jack_time_t,
    pub valid: jack_transport_bits_t,
    pub transport_state: jack_transport_state_t,
    pub frame: jack_nframes_t,
    pub loop_start: jack_nframes_t,
    pub loop_end: jack_nframes_t,
    pub smpte_offset: ::libc::c_long,
    pub smpte_frame_rate: ::libc::c_float,
    pub bar: ::libc::c_int,
    pub beat: ::libc::c_int,
    pub tick: ::libc::c_int,
    pub bar_start_tick: ::libc::c_double,
    pub beats_per_bar: ::libc::c_float,
    pub beat_type: ::libc::c_float,
    pub ticks_per_beat: ::libc::c_double,
    pub beats_per_minute: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_transport_info_t = Struct_Unnamed4;
pub type jack_thread_creator_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::libc::pthread_t,
        arg2: *const ::libc::pthread_attr_t,
        function: ::std::option::Option<
            extern "C" fn(arg1: *mut ::libc::c_void) -> *mut ::libc::c_void,
        >,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int,
>;
pub type Enum_JackSessionEventType = ::libc::c_uint;
pub const JackSessionSave: ::libc::c_uint = 1;
pub const JackSessionSaveAndQuit: ::libc::c_uint = 2;
pub const JackSessionSaveTemplate: ::libc::c_uint = 3;
pub type jack_session_event_type_t = Enum_JackSessionEventType;
pub type Enum_JackSessionFlags = ::libc::c_uint;
pub const JackSessionSaveError: ::libc::c_uint = 1;
pub const JackSessionNeedTerminal: ::libc::c_uint = 2;
pub type jack_session_flags_t = Enum_JackSessionFlags;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__jack_session_event {
    pub _type: jack_session_event_type_t,
    pub session_dir: *const ::libc::c_char,
    pub client_uuid: *const ::libc::c_char,
    pub command_line: *mut ::libc::c_char,
    pub flags: jack_session_flags_t,
    pub future: ::libc::uint32_t,
}
impl ::std::clone::Clone for Struct__jack_session_event {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct__jack_session_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_session_event_t = Struct__jack_session_event;
pub type JackSessionCallback = ::std::option::Option<
    unsafe extern "C" fn(event: *mut jack_session_event_t, arg: *mut ::libc::c_void) -> (),
>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed5 {
    pub uuid: *const ::libc::c_char,
    pub client_name: *const ::libc::c_char,
    pub command: *const ::libc::c_char,
    pub flags: jack_session_flags_t,
}
impl ::std::clone::Clone for Struct_Unnamed5 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_session_command_t = Struct_Unnamed5;
pub type JSList = Struct__JSList;
pub type JCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut ::libc::c_void, b: *mut ::libc::c_void) -> ::libc::c_int,
>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__JSList {
    pub data: *mut ::libc::c_void,
    pub next: *mut JSList,
}
impl ::std::clone::Clone for Struct__JSList {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct__JSList {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed6 = ::libc::c_uint;
pub const JackParamInt: ::libc::c_uint = 1;
pub const JackParamUInt: ::libc::c_uint = 2;
pub const JackParamChar: ::libc::c_uint = 3;
pub const JackParamString: ::libc::c_uint = 4;
pub const JackParamBool: ::libc::c_uint = 5;
pub type jackctl_param_type_t = Enum_Unnamed6;
pub type Enum_Unnamed7 = ::libc::c_uint;
pub const JackMaster: ::libc::c_uint = 1;
pub const JackSlave: ::libc::c_uint = 2;
pub type jackctl_driver_type_t = Enum_Unnamed7;
#[repr(C)]
#[derive(Copy)]
pub struct Union_jackctl_parameter_value {
    pub _bindgen_data_: [u32; 32usize],
}
impl Union_jackctl_parameter_value {
    pub unsafe fn ui(&mut self) -> *mut ::libc::uint32_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn i(&mut self) -> *mut ::libc::int32_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn c(&mut self) -> *mut ::libc::c_char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn str(&mut self) -> *mut [::libc::c_char; 128usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn b(&mut self) -> *mut u8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_jackctl_parameter_value {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Union_jackctl_parameter_value {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct_jackctl_server {
}
pub type jackctl_server_t = Struct_jackctl_server;
pub enum Struct_jackctl_driver {
}
pub type jackctl_driver_t = Struct_jackctl_driver;
pub enum Struct_jackctl_internal {
}
pub type jackctl_internal_t = Struct_jackctl_internal;
pub enum Struct_jackctl_parameter {
}
pub type jackctl_parameter_t = Struct_jackctl_parameter;
pub enum Struct_jackctl_sigmask {
}
pub type jackctl_sigmask_t = Struct_jackctl_sigmask;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed8 {
    pub key: *const ::libc::c_char,
    pub data: *const ::libc::c_char,
    pub _type: *const ::libc::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed8 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed8 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_property_t = Struct_Unnamed8;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub subject: jack_uuid_t,
    pub property_cnt: ::libc::uint32_t,
    pub properties: *mut jack_property_t,
    pub property_size: ::libc::uint32_t,
}
impl ::std::clone::Clone for Struct_Unnamed9 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_description_t = Struct_Unnamed9;
pub type Enum_Unnamed10 = ::libc::c_uint;
pub const PropertyCreated: ::libc::c_uint = 0;
pub const PropertyChanged: ::libc::c_uint = 1;
pub const PropertyDeleted: ::libc::c_uint = 2;
pub type jack_property_change_t = Enum_Unnamed10;
pub type JackPropertyChangeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        subject: jack_uuid_t,
        key: *const ::libc::c_char,
        change: jack_property_change_t,
        arg: *mut ::libc::c_void,
    ) -> (),
>;
pub type jack_midi_data_t = ::libc::c_uchar;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__jack_midi_event {
    pub time: jack_nframes_t,
    pub size: ::libc::size_t,
    pub buffer: *mut jack_midi_data_t,
}
impl ::std::clone::Clone for Struct__jack_midi_event {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct__jack_midi_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_midi_event_t = Struct__jack_midi_event;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub buf: *mut ::libc::c_char,
    pub len: ::libc::size_t,
}
impl ::std::clone::Clone for Struct_Unnamed11 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_ringbuffer_data_t = Struct_Unnamed11;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed12 {
    pub buf: *mut ::libc::c_char,
    pub write_ptr: ::libc::size_t,
    pub read_ptr: ::libc::size_t,
    pub size: ::libc::size_t,
    pub size_mask: ::libc::size_t,
    pub mlocked: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed12 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed12 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type jack_ringbuffer_t = Struct_Unnamed12;
extern "C" {
    pub static mut jack_error_callback:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ::libc::c_char) -> ()>;
    pub static mut jack_info_callback:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ::libc::c_char) -> ()>;
    pub static mut JACK_METADATA_PRETTY_NAME: *const ::libc::c_char;
    pub static mut JACK_METADATA_HARDWARE: *const ::libc::c_char;
    pub static mut JACK_METADATA_CONNECTED: *const ::libc::c_char;
    pub static mut JACK_METADATA_PORT_GROUP: *const ::libc::c_char;
    pub static mut JACK_METADATA_ICON_SMALL: *const ::libc::c_char;
    pub static mut JACK_METADATA_ICON_LARGE: *const ::libc::c_char;
}

#[link(name = "jack")]
extern "C" {
    pub fn jack_release_timebase(client: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_set_sync_callback(
        client: *mut jack_client_t,
        sync_callback: JackSyncCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_sync_timeout(client: *mut jack_client_t, timeout: jack_time_t)
        -> ::libc::c_int;
    pub fn jack_set_timebase_callback(
        client: *mut jack_client_t,
        conditional: ::libc::c_int,
        timebase_callback: TimebaseCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_transport_locate(
        client: *mut jack_client_t,
        frame: jack_nframes_t,
    ) -> ::libc::c_int;
    pub fn jack_transport_query(
        client: *const jack_client_t,
        pos: *mut jack_position_t,
    ) -> jack_transport_state_t;
    pub fn jack_get_current_transport_frame(client: *const jack_client_t) -> jack_nframes_t;
    pub fn jack_transport_reposition(
        client: *mut jack_client_t,
        pos: *const jack_position_t,
    ) -> ::libc::c_int;
    pub fn jack_transport_start(client: *mut jack_client_t) -> ();
    pub fn jack_transport_stop(client: *mut jack_client_t) -> ();
    pub fn jack_get_transport_info(
        client: *mut jack_client_t,
        tinfo: *mut jack_transport_info_t,
    ) -> ();
    pub fn jack_set_transport_info(
        client: *mut jack_client_t,
        tinfo: *mut jack_transport_info_t,
    ) -> ();
    pub fn jack_get_version(
        major_ptr: *mut ::libc::c_int,
        minor_ptr: *mut ::libc::c_int,
        micro_ptr: *mut ::libc::c_int,
        proto_ptr: *mut ::libc::c_int,
    ) -> ();
    pub fn jack_get_version_string() -> *const ::libc::c_char;
    pub fn jack_client_open(
        client_name: *const ::libc::c_char,
        options: jack_options_t,
        status: *mut jack_status_t,
        ...
    ) -> *mut jack_client_t;
    pub fn jack_client_new(client_name: *const ::libc::c_char) -> *mut jack_client_t;
    pub fn jack_client_close(client: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_client_name_size() -> ::libc::c_int;
    pub fn jack_get_client_name(client: *mut jack_client_t) -> *mut ::libc::c_char;
    pub fn jack_get_uuid_for_client_name(
        client: *mut jack_client_t,
        client_name: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
    pub fn jack_get_client_name_by_uuid(
        client: *mut jack_client_t,
        client_uuid: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
    pub fn jack_internal_client_new(
        client_name: *const ::libc::c_char,
        load_name: *const ::libc::c_char,
        load_init: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_internal_client_close(client_name: *const ::libc::c_char) -> ();
    pub fn jack_activate(client: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_deactivate(client: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_get_client_pid(name: *const ::libc::c_char) -> ::libc::c_int;
    pub fn jack_client_thread_id(client: *mut jack_client_t) -> jack_native_thread_t;
    pub fn jack_is_realtime(client: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_thread_wait(client: *mut jack_client_t, status: ::libc::c_int) -> jack_nframes_t;
    pub fn jack_cycle_wait(client: *mut jack_client_t) -> jack_nframes_t;
    pub fn jack_cycle_signal(client: *mut jack_client_t, status: ::libc::c_int) -> ();
    pub fn jack_set_process_thread(
        client: *mut jack_client_t,
        thread_callback: JackThreadCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_thread_init_callback(
        client: *mut jack_client_t,
        thread_init_callback: JackThreadInitCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_on_shutdown(
        client: *mut jack_client_t,
        shutdown_callback: JackShutdownCallback,
        arg: *mut ::libc::c_void,
    ) -> ();
    pub fn jack_on_info_shutdown(
        client: *mut jack_client_t,
        shutdown_callback: JackInfoShutdownCallback,
        arg: *mut ::libc::c_void,
    ) -> ();
    pub fn jack_set_process_callback(
        client: *mut jack_client_t,
        process_callback: JackProcessCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_freewheel_callback(
        client: *mut jack_client_t,
        freewheel_callback: JackFreewheelCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_buffer_size_callback(
        client: *mut jack_client_t,
        bufsize_callback: JackBufferSizeCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_sample_rate_callback(
        client: *mut jack_client_t,
        srate_callback: JackSampleRateCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_client_registration_callback(
        client: *mut jack_client_t,
        registration_callback: JackClientRegistrationCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_port_registration_callback(
        client: *mut jack_client_t,
        registration_callback: JackPortRegistrationCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_port_connect_callback(
        client: *mut jack_client_t,
        connect_callback: JackPortConnectCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_port_rename_callback(
        client: *mut jack_client_t,
        rename_callback: JackPortRenameCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_graph_order_callback(
        client: *mut jack_client_t,
        graph_callback: JackGraphOrderCallback,
        arg1: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_xrun_callback(
        client: *mut jack_client_t,
        xrun_callback: JackXRunCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_latency_callback(
        client: *mut jack_client_t,
        latency_callback: JackLatencyCallback,
        arg1: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_set_freewheel(client: *mut jack_client_t, onoff: ::libc::c_int) -> ::libc::c_int;
    pub fn jack_set_buffer_size(
        client: *mut jack_client_t,
        nframes: jack_nframes_t,
    ) -> ::libc::c_int;
    pub fn jack_get_sample_rate(arg1: *mut jack_client_t) -> jack_nframes_t;
    pub fn jack_get_buffer_size(arg1: *mut jack_client_t) -> jack_nframes_t;
    pub fn jack_engine_takeover_timebase(arg1: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_cpu_load(client: *mut jack_client_t) -> ::libc::c_float;
    pub fn jack_port_register(
        client: *mut jack_client_t,
        port_name: *const ::libc::c_char,
        port_type: *const ::libc::c_char,
        flags: ::libc::c_ulong,
        buffer_size: ::libc::c_ulong,
    ) -> *mut jack_port_t;
    pub fn jack_port_unregister(
        client: *mut jack_client_t,
        port: *mut jack_port_t,
    ) -> ::libc::c_int;
    pub fn jack_port_get_buffer(
        port: *mut jack_port_t,
        arg1: jack_nframes_t,
    ) -> *mut ::libc::c_void;
    pub fn jack_port_uuid(port: *const jack_port_t) -> jack_uuid_t;
    pub fn jack_port_name(port: *const jack_port_t) -> *const ::libc::c_char;
    pub fn jack_port_short_name(port: *const jack_port_t) -> *const ::libc::c_char;
    pub fn jack_port_flags(port: *const jack_port_t) -> ::libc::c_int;
    pub fn jack_port_type(port: *const jack_port_t) -> *const ::libc::c_char;
    pub fn jack_port_type_id(port: *const jack_port_t) -> jack_port_type_id_t;
    pub fn jack_port_is_mine(
        client: *const jack_client_t,
        port: *const jack_port_t,
    ) -> ::libc::c_int;
    pub fn jack_port_connected(port: *const jack_port_t) -> ::libc::c_int;
    pub fn jack_port_connected_to(
        port: *const jack_port_t,
        port_name: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_port_get_connections(port: *const jack_port_t) -> *mut *const ::libc::c_char;
    pub fn jack_port_get_all_connections(
        client: *const jack_client_t,
        port: *const jack_port_t,
    ) -> *mut *const ::libc::c_char;
    pub fn jack_port_tie(src: *mut jack_port_t, dst: *mut jack_port_t) -> ::libc::c_int;
    pub fn jack_port_untie(port: *mut jack_port_t) -> ::libc::c_int;
    pub fn jack_port_set_name(
        port: *mut jack_port_t,
        port_name: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_port_set_alias(
        port: *mut jack_port_t,
        alias: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_port_unset_alias(
        port: *mut jack_port_t,
        alias: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_port_get_aliases(
        port: *const jack_port_t,
        aliases: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_port_request_monitor(port: *mut jack_port_t, onoff: ::libc::c_int)
        -> ::libc::c_int;
    pub fn jack_port_request_monitor_by_name(
        client: *mut jack_client_t,
        port_name: *const ::libc::c_char,
        onoff: ::libc::c_int,
    ) -> ::libc::c_int;
    pub fn jack_port_ensure_monitor(port: *mut jack_port_t, onoff: ::libc::c_int) -> ::libc::c_int;
    pub fn jack_port_monitoring_input(port: *mut jack_port_t) -> ::libc::c_int;
    pub fn jack_connect(
        client: *mut jack_client_t,
        source_port: *const ::libc::c_char,
        destination_port: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_disconnect(
        client: *mut jack_client_t,
        source_port: *const ::libc::c_char,
        destination_port: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_port_disconnect(
        client: *mut jack_client_t,
        port: *mut jack_port_t,
    ) -> ::libc::c_int;
    pub fn jack_port_name_size() -> ::libc::c_int;
    pub fn jack_port_type_size() -> ::libc::c_int;
    pub fn jack_port_type_get_buffer_size(
        client: *mut jack_client_t,
        port_type: *const ::libc::c_char,
    ) -> ::libc::size_t;
    pub fn jack_port_set_latency(port: *mut jack_port_t, arg1: jack_nframes_t) -> ();
    pub fn jack_port_get_latency_range(
        port: *mut jack_port_t,
        mode: jack_latency_callback_mode_t,
        range: *mut jack_latency_range_t,
    ) -> ();
    pub fn jack_port_set_latency_range(
        port: *mut jack_port_t,
        mode: jack_latency_callback_mode_t,
        range: *mut jack_latency_range_t,
    ) -> ();
    pub fn jack_recompute_total_latencies(client: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_port_get_latency(port: *mut jack_port_t) -> jack_nframes_t;
    pub fn jack_port_get_total_latency(
        client: *mut jack_client_t,
        port: *mut jack_port_t,
    ) -> jack_nframes_t;
    pub fn jack_recompute_total_latency(
        arg1: *mut jack_client_t,
        port: *mut jack_port_t,
    ) -> ::libc::c_int;
    pub fn jack_get_ports(
        client: *mut jack_client_t,
        port_name_pattern: *const ::libc::c_char,
        type_name_pattern: *const ::libc::c_char,
        flags: ::libc::c_ulong,
    ) -> *mut *const ::libc::c_char;
    pub fn jack_port_by_name(
        client: *mut jack_client_t,
        port_name: *const ::libc::c_char,
    ) -> *mut jack_port_t;
    pub fn jack_port_by_id(client: *mut jack_client_t, port_id: jack_port_id_t)
        -> *mut jack_port_t;
    pub fn jack_frames_since_cycle_start(arg1: *const jack_client_t) -> jack_nframes_t;
    pub fn jack_frame_time(arg1: *const jack_client_t) -> jack_nframes_t;
    pub fn jack_last_frame_time(client: *const jack_client_t) -> jack_nframes_t;

    pub fn jack_frames_to_time(client: *const jack_client_t, arg1: jack_nframes_t) -> jack_time_t;
    pub fn jack_time_to_frames(client: *const jack_client_t, arg1: jack_time_t) -> jack_nframes_t;
    pub fn jack_get_time() -> jack_time_t;
    pub fn jack_set_error_function(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_char) -> ()>,
    ) -> ();
    pub fn jack_set_info_function(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_char) -> ()>,
    ) -> ();
    pub fn jack_free(ptr: *mut ::libc::c_void) -> ();
    pub fn jack_client_real_time_priority(arg1: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_client_max_real_time_priority(arg1: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_acquire_real_time_scheduling(
        thread: jack_native_thread_t,
        priority: ::libc::c_int,
    ) -> ::libc::c_int;
    pub fn jack_client_create_thread(
        client: *mut jack_client_t,
        thread: *mut jack_native_thread_t,
        priority: ::libc::c_int,
        realtime: ::libc::c_int,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void) -> *mut ::libc::c_void,
        >,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_drop_real_time_scheduling(thread: jack_native_thread_t) -> ::libc::c_int;
    pub fn jack_client_stop_thread(
        client: *mut jack_client_t,
        thread: jack_native_thread_t,
    ) -> ::libc::c_int;
    pub fn jack_client_kill_thread(
        client: *mut jack_client_t,
        thread: jack_native_thread_t,
    ) -> ::libc::c_int;
    pub fn jack_set_thread_creator(creator: jack_thread_creator_t) -> ();
    pub fn jack_set_session_callback(
        client: *mut jack_client_t,
        session_callback: JackSessionCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_session_reply(
        client: *mut jack_client_t,
        event: *mut jack_session_event_t,
    ) -> ::libc::c_int;
    pub fn jack_session_event_free(event: *mut jack_session_event_t) -> ();
    pub fn jack_client_get_uuid(client: *mut jack_client_t) -> *mut ::libc::c_char;
    pub fn jack_session_notify(
        client: *mut jack_client_t,
        target: *const ::libc::c_char,
        _type: jack_session_event_type_t,
        path: *const ::libc::c_char,
    ) -> *mut jack_session_command_t;
    pub fn jack_session_commands_free(cmds: *mut jack_session_command_t) -> ();
    pub fn jack_reserve_client_name(
        client: *mut jack_client_t,
        name: *const ::libc::c_char,
        uuid: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_client_has_session_callback(
        client: *mut jack_client_t,
        client_name: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jackctl_setup_signals(flags: ::libc::c_uint) -> *mut jackctl_sigmask_t;
    pub fn jackctl_wait_signals(signals: *mut jackctl_sigmask_t) -> ();
    pub fn jackctl_server_create(
        on_device_acquire: ::std::option::Option<
            unsafe extern "C" fn(device_name: *const ::libc::c_char) -> u8,
        >,
        on_device_release: ::std::option::Option<
            unsafe extern "C" fn(device_name: *const ::libc::c_char) -> (),
        >,
    ) -> *mut jackctl_server_t;
    pub fn jackctl_server_destroy(server: *mut jackctl_server_t) -> ();
    pub fn jackctl_server_open(server: *mut jackctl_server_t, driver: *mut jackctl_driver_t) -> u8;
    pub fn jackctl_server_start(server: *mut jackctl_server_t) -> u8;
    pub fn jackctl_server_stop(server: *mut jackctl_server_t) -> u8;
    pub fn jackctl_server_close(server: *mut jackctl_server_t) -> u8;
    pub fn jackctl_server_get_drivers_list(server: *mut jackctl_server_t) -> *const JSList;
    pub fn jackctl_server_get_parameters(server: *mut jackctl_server_t) -> *const JSList;
    pub fn jackctl_server_get_internals_list(server: *mut jackctl_server_t) -> *const JSList;
    pub fn jackctl_server_load_internal(
        server: *mut jackctl_server_t,
        internal: *mut jackctl_internal_t,
    ) -> u8;
    pub fn jackctl_server_unload_internal(
        server: *mut jackctl_server_t,
        internal: *mut jackctl_internal_t,
    ) -> u8;
    pub fn jackctl_server_add_slave(
        server: *mut jackctl_server_t,
        driver: *mut jackctl_driver_t,
    ) -> u8;
    pub fn jackctl_server_remove_slave(
        server: *mut jackctl_server_t,
        driver: *mut jackctl_driver_t,
    ) -> u8;
    pub fn jackctl_server_switch_master(
        server: *mut jackctl_server_t,
        driver: *mut jackctl_driver_t,
    ) -> u8;
    pub fn jackctl_driver_get_name(driver: *mut jackctl_driver_t) -> *const ::libc::c_char;
    pub fn jackctl_driver_get_type(driver: *mut jackctl_driver_t) -> jackctl_driver_type_t;
    pub fn jackctl_driver_get_parameters(driver: *mut jackctl_driver_t) -> *const JSList;
    pub fn jackctl_driver_params_parse(
        driver: *mut jackctl_driver_t,
        argc: ::libc::c_int,
        argv: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jackctl_internal_get_name(internal: *mut jackctl_internal_t) -> *const ::libc::c_char;
    pub fn jackctl_internal_get_parameters(internal: *mut jackctl_internal_t) -> *const JSList;
    pub fn jackctl_parameter_get_name(parameter: *mut jackctl_parameter_t)
        -> *const ::libc::c_char;
    pub fn jackctl_parameter_get_short_description(
        parameter: *mut jackctl_parameter_t,
    ) -> *const ::libc::c_char;
    pub fn jackctl_parameter_get_long_description(
        parameter: *mut jackctl_parameter_t,
    ) -> *const ::libc::c_char;
    pub fn jackctl_parameter_get_type(parameter: *mut jackctl_parameter_t) -> jackctl_param_type_t;
    pub fn jackctl_parameter_get_id(parameter: *mut jackctl_parameter_t) -> ::libc::c_char;
    pub fn jackctl_parameter_is_set(parameter: *mut jackctl_parameter_t) -> u8;
    pub fn jackctl_parameter_reset(parameter: *mut jackctl_parameter_t) -> u8;
    pub fn jackctl_parameter_get_value(
        parameter: *mut jackctl_parameter_t,
    ) -> Union_jackctl_parameter_value;
    pub fn jackctl_parameter_set_value(
        parameter: *mut jackctl_parameter_t,
        value_ptr: *const Union_jackctl_parameter_value,
    ) -> u8;
    pub fn jackctl_parameter_get_default_value(
        parameter: *mut jackctl_parameter_t,
    ) -> Union_jackctl_parameter_value;
    pub fn jackctl_parameter_has_range_constraint(parameter: *mut jackctl_parameter_t) -> u8;
    pub fn jackctl_parameter_has_enum_constraint(parameter: *mut jackctl_parameter_t) -> u8;
    pub fn jackctl_parameter_get_enum_constraints_count(
        parameter: *mut jackctl_parameter_t,
    ) -> ::libc::uint32_t;
    pub fn jackctl_parameter_get_enum_constraint_value(
        parameter: *mut jackctl_parameter_t,
        index: ::libc::uint32_t,
    ) -> Union_jackctl_parameter_value;
    pub fn jackctl_parameter_get_enum_constraint_description(
        parameter: *mut jackctl_parameter_t,
        index: ::libc::uint32_t,
    ) -> *const ::libc::c_char;
    pub fn jackctl_parameter_get_range_constraint(
        parameter: *mut jackctl_parameter_t,
        min_ptr: *mut Union_jackctl_parameter_value,
        max_ptr: *mut Union_jackctl_parameter_value,
    ) -> ();
    pub fn jackctl_parameter_constraint_is_strict(parameter: *mut jackctl_parameter_t) -> u8;
    pub fn jackctl_parameter_constraint_is_fake_value(parameter: *mut jackctl_parameter_t) -> u8;
    pub fn jack_error(format: *const ::libc::c_char, ...) -> ();
    pub fn jack_info(format: *const ::libc::c_char, ...) -> ();
    pub fn jack_log(format: *const ::libc::c_char, ...) -> ();
    pub fn jack_set_property(
        arg1: *mut jack_client_t,
        subject: jack_uuid_t,
        key: *const ::libc::c_char,
        value: *const ::libc::c_char,
        _type: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_get_property(
        subject: jack_uuid_t,
        key: *const ::libc::c_char,
        value: *mut *mut ::libc::c_char,
        _type: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_free_description(
        desc: *mut jack_description_t,
        free_description_itself: ::libc::c_int,
    ) -> ();
    pub fn jack_get_properties(
        subject: jack_uuid_t,
        desc: *mut jack_description_t,
    ) -> ::libc::c_int;
    pub fn jack_get_all_properties(descs: *mut *mut jack_description_t) -> ::libc::c_int;
    pub fn jack_remove_property(
        client: *mut jack_client_t,
        subject: jack_uuid_t,
        key: *const ::libc::c_char,
    ) -> ::libc::c_int;
    pub fn jack_remove_properties(
        client: *mut jack_client_t,
        subject: jack_uuid_t,
    ) -> ::libc::c_int;
    pub fn jack_remove_all_properties(client: *mut jack_client_t) -> ::libc::c_int;
    pub fn jack_set_property_change_callback(
        client: *mut jack_client_t,
        callback: JackPropertyChangeCallback,
        arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
    pub fn jack_get_internal_client_name(
        client: *mut jack_client_t,
        intclient: jack_intclient_t,
    ) -> *mut ::libc::c_char;
    pub fn jack_internal_client_handle(
        client: *mut jack_client_t,
        client_name: *const ::libc::c_char,
        status: *mut jack_status_t,
    ) -> jack_intclient_t;
    pub fn jack_internal_client_load(
        client: *mut jack_client_t,
        client_name: *const ::libc::c_char,
        options: jack_options_t,
        status: *mut jack_status_t,
        ...
    ) -> jack_intclient_t;
    pub fn jack_internal_client_unload(
        client: *mut jack_client_t,
        intclient: jack_intclient_t,
    ) -> jack_status_t;
    pub fn jack_get_max_delayed_usecs(client: *mut jack_client_t) -> ::libc::c_float;
    pub fn jack_get_xrun_delayed_usecs(client: *mut jack_client_t) -> ::libc::c_float;
    pub fn jack_reset_max_delayed_usecs(client: *mut jack_client_t) -> ();
    pub fn jack_midi_get_event_count(port_buffer: *mut ::libc::c_void) -> ::libc::uint32_t;
    pub fn jack_midi_event_get(
        event: *mut jack_midi_event_t,
        port_buffer: *mut ::libc::c_void,
        event_index: ::libc::uint32_t,
    ) -> ::libc::c_int;
    pub fn jack_midi_clear_buffer(port_buffer: *mut ::libc::c_void) -> ();
    pub fn jack_midi_reset_buffer(port_buffer: *mut ::libc::c_void) -> ();
    pub fn jack_midi_max_event_size(port_buffer: *mut ::libc::c_void) -> ::libc::size_t;
    pub fn jack_midi_event_reserve(
        port_buffer: *mut ::libc::c_void,
        time: jack_nframes_t,
        data_size: ::libc::size_t,
    ) -> *mut jack_midi_data_t;
    pub fn jack_midi_event_write(
        port_buffer: *mut ::libc::c_void,
        time: jack_nframes_t,
        data: *const jack_midi_data_t,
        data_size: ::libc::size_t,
    ) -> ::libc::c_int;
    pub fn jack_midi_get_lost_event_count(port_buffer: *mut ::libc::c_void) -> ::libc::uint32_t;
    pub fn jack_ringbuffer_create(sz: ::libc::size_t) -> *mut jack_ringbuffer_t;
    pub fn jack_ringbuffer_free(rb: *mut jack_ringbuffer_t) -> ();
    pub fn jack_ringbuffer_get_read_vector(
        rb: *const jack_ringbuffer_t,
        vec: *mut jack_ringbuffer_data_t,
    ) -> ();
    pub fn jack_ringbuffer_get_write_vector(
        rb: *const jack_ringbuffer_t,
        vec: *mut jack_ringbuffer_data_t,
    ) -> ();
    pub fn jack_ringbuffer_read(
        rb: *mut jack_ringbuffer_t,
        dest: *mut ::libc::c_char,
        cnt: ::libc::size_t,
    ) -> ::libc::size_t;
    pub fn jack_ringbuffer_peek(
        rb: *mut jack_ringbuffer_t,
        dest: *mut ::libc::c_char,
        cnt: ::libc::size_t,
    ) -> ::libc::size_t;
    pub fn jack_ringbuffer_read_advance(rb: *mut jack_ringbuffer_t, cnt: ::libc::size_t) -> ();
    pub fn jack_ringbuffer_read_space(rb: *const jack_ringbuffer_t) -> ::libc::size_t;
    pub fn jack_ringbuffer_mlock(rb: *mut jack_ringbuffer_t) -> ::libc::c_int;
    pub fn jack_ringbuffer_reset(rb: *mut jack_ringbuffer_t) -> ();
    pub fn jack_ringbuffer_reset_size(rb: *mut jack_ringbuffer_t, sz: ::libc::size_t) -> ();
    pub fn jack_ringbuffer_write(
        rb: *mut jack_ringbuffer_t,
        src: *const ::libc::c_char,
        cnt: ::libc::size_t,
    ) -> ::libc::size_t;
    pub fn jack_ringbuffer_write_advance(rb: *mut jack_ringbuffer_t, cnt: ::libc::size_t) -> ();
    pub fn jack_ringbuffer_write_space(rb: *const jack_ringbuffer_t) -> ::libc::size_t;
}

// Load optional functions:

#[cfg(windows)]
const jack_lib: &'static str = "libjack.dll";

#[cfg(unix)]
const jack_lib: &'static str = "libjack.so";

type jack_get_cycle_times_t = unsafe extern "C" fn(
    client: *const jack_client_t,
    current_frames: *mut jack_nframes_t,
    current_usecs: *mut jack_time_t,
    next_usecs: *mut jack_time_t,
    period_usecs: *mut ::libc::c_float,
) -> ::libc::c_int;

lazy_static! {
pub static ref jack_get_cycle_times : Option<jack_get_cycle_times_t> = {
        if let Ok(lib) = libloading::Library::new(jack_lib) {
            unsafe {
                if let Ok(sym) = lib.get::<jack_get_cycle_times_t>(b"jack_get_cycle_times\0") {
                    let sym = sym.into_raw();
                    Some(*sym.deref() as jack_get_cycle_times_t)
                } else {
                    None
                }
            }
        } else {
            None
        }
    };
}
